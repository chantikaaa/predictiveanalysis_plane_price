# -*- coding: utf-8 -*-
"""predictive-analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sS-ku6ACC-rE-f_-nqsMwyjQez2ZFM3z

# Regression Predictive Analysis : Plane Price Prediction

### Import Library

Pada tahap ini, diimpor beberapa pustaka (library) Python yang dibutuhkan untuk analisis data dan pembangunan model machine learning.
"""

import pandas as pd
import os
import numpy as np
import kagglehub
from google.colab import drive
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.preprocessing import RobustScaler
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.feature_selection import SelectKBest, f_regression
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

"""### Data Loading

Memuat dataset plane price prediction dari Kaggle menggunakan kagglehub
"""

drive.mount('/content/drive')

# Download latest version
path = kagglehub.dataset_download("rafsunahmad/plane-price-prediction")
print("Path ke file yang diunduh:", path)

print("Path to dataset files:", path)

try:
    file_name = 'Plane Price.csv'
    file_path = os.path.join(path, file_name)
    df = pd.read_csv(file_path)
    print("\nDataFrame loaded successfully:")
    print(df.head())
except FileNotFoundError:
    print(f"Error: The file '{file_name}' was not found in the downloaded directory.")
except Exception as e:
    print(f"An error occurred while reading the CSV file: {e}")

df.head(5)

"""### Exploratory Data Analysis (EDA)

Dilakukan Exploratory Data Analysis (EDA) pada dataset dengan tujuan untuk memahami data lebih dalam, menemukan pola tersembunyi, dan mengidentifikasi anomali atau masalah dalam data sebelum membangun model machine learning.
"""

df.sample(10)

df.shape

df.info()

df.describe()

# Memeriksa duplikasi data
jumlah_duplikat = df.duplicated().sum()
print(f"Jumlah baris duplikat: {jumlah_duplikat}")

# Memeriksa data null
df.isna().sum()

distinct_engine = df["Engine Type"].unique()
print(distinct_engine)

# Hitung Correlation Matrix
correlation_matrix = df.corr(numeric_only=True)
# Parameter numeric_only=True memastikan hanya kolom numerik yang dihitung korelasinya

# Visualisasi Correlation Matrix menggunakan Heatmap
plt.figure(figsize=(12, 10))  # Atur ukuran plot agar lebih mudah dibaca
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=.5)

plt.title('Correlation Matrix Antar Fitur')
plt.show()

# Visualisasi dengan pairplot untuk semua fitur sekaligus dengan Price
# Dapatkan list semua kolom numerik
numeric_cols = df.select_dtypes(include=['int64', 'float64']).columns.tolist()
# Buat list fitur numerik selain 'Price' untuk x_vars
numeric_features_no_price = [col for col in numeric_cols if col != 'Price']

# Buat pairplot dengan 'Price' sebagai y_vars dan fitur numerik lainnya sebagai x_vars
sns.pairplot(df, y_vars=['Price'], x_vars=numeric_features_no_price)
plt.suptitle('Pairplot Fitur Numerik terhadap Price', y=1.02)
plt.show()

# Buat boxplot untuk setiap kolom numerik untuk mendeteksi outlier
plt.figure(figsize=(15, 10))
for i, col in enumerate(numeric_cols):
    plt.subplot(3, len(numeric_cols) // 3 + (1 if len(numeric_cols) % 3 > 0 else 0), i + 1)
    sns.boxplot(x=df[col])
    plt.title(f'Boxplot untuk {col}')
    plt.xlabel(col)
plt.tight_layout()
plt.suptitle('Boxplot untuk Deteksi Outlier pada Fitur Numerik', y=1.02)
plt.show()

# Outlier
# Menentukan quartile dan interquartile
q1 = df[numeric_cols].quantile(0.25)
q3 = df[numeric_cols].quantile(0.75)
IQR = q3 - q1
# Menentukan batas bawah dan atas untuk mendeteksi outlier
lower_bound = q1 - 1.5 * IQR
upper_bound = q3 + 1.5 * IQR

# Menampilkan jumlah outlier per fitur
outliers = ((df[numeric_cols] < lower_bound) | (df[numeric_cols] > upper_bound)).sum()
print(outliers)

# Visualisasi fitur kategorik; Engine Type
plt.figure(figsize=(8, 6))
sns.countplot(x=df['Engine Type'])
plt.title('Distribusi Frekuensi Engine Type')
plt.xlabel('Engine Type')
plt.ylabel('Jumlah')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""### Data Preparation/Preprocessing

Data preparation/preprocessing dilakukan pada dataset untuk membersihkan, mengubah, dan mentransformasi data mentah menjadi format yang sesuai dan berkualitas tinggi agar dapat digunakan secara efektif oleh model machine learning.

Hilangkan feature model name, karena kurang relevan untuk price prediction
"""

pred_columns = [col for col in df.columns if col != 'Model Name']
df = df[pred_columns]

# Memeriksa apakah kolom "Model Name" sudah tidak ada
df.info()

# Ubah tipe data ke numeric karena ada beberapa fitur yang masih object
numeric_cols = ['HP or lbs thr ea engine', 'Max speed Knots', 'All eng rate of climb', 'Landing over 50ft', 'Empty weight lbs', 'Range N.M.']
# Hilangkan koma dan ubah tipe data menjadi float
for col in numeric_cols:
    # Menghilangkan koma dan spasi lalu ubah ke float
    df[col] = df[col].str.replace(',', '', regex=True)
    df[col] = pd.to_numeric(df[col], errors='coerce')

# Ubah feature dengan ft/in menjadi numeric
# Fungsi untuk mengonversi panjang dari format ft/in ke inci
def ft_in_to_inches(length):
    try:
        ft, inch = length.split('/')
        ft = int(ft)
        inch = int(inch)
        return ft * 12 + inch
    except:
        return np.nan

# Mengonversi dan memastikan tipe data numeric
df['Length ft/in'] = df['Length ft/in'].apply(ft_in_to_inches)
df['Length ft/in'] = pd.to_numeric(df['Length ft/in'], errors='coerce')

df['Wing span ft/in'] = df['Wing span ft/in'].apply(ft_in_to_inches)
df['Wing span ft/in'] = pd.to_numeric(df['Wing span ft/in'], errors='coerce')

# Mengisi nilai NaN dengan median (jika ada)
df['Length ft/in'] = df['Length ft/in'].fillna(df['Length ft/in'].median())
df['Wing span ft/in'] = df['Wing span ft/in'].fillna(df['Wing span ft/in'].median())

# Verifikasi tipe data
print(df[['Length ft/in', 'Wing span ft/in']].dtypes)

# Ganti "piston" menjadi "Piston"
df['Engine Type'] = df['Engine Type'].str.replace('piston', 'Piston').astype(str)

# Periksa apakah piston sudah tidak ada
print((df['Engine Type'] == "piston").sum())

"""#### Mengatasi nilai null/missing values

Karena nilai null cukup banyak, agar menghindari kehilangan cukup banyak data juga, maka diisi dengan menggunakan nilai median atau modus
"""

numeric_cols = df.select_dtypes(include=[np.number]).columns
df[numeric_cols] = df[numeric_cols].fillna(df[numeric_cols].median())

# Periksa ulang jumlah missing value
df.isna().sum()

df.info()

"""#### Mengatasi outlier"""

# Buat boxplot untuk setiap kolom numerik untuk mendeteksi outlier manakah yang sebaiknya diatasi
plt.figure(figsize=(15, 10))
for i, col in enumerate(numeric_cols):
    plt.subplot(3, len(numeric_cols) // 3 + (1 if len(numeric_cols) % 3 > 0 else 0), i + 1)
    sns.boxplot(x=df[col])
    plt.title(f'Boxplot untuk {col}')
    plt.xlabel(col)
plt.tight_layout()
plt.suptitle('Boxplot untuk Deteksi Outlier pada Fitur Numerik', y=1.02)
plt.show()

# Hitung Correlation Matrix untuk mengetahui mendeteksi outlier manakah yang sebaiknya diatasi
correlation_matrix = df.corr(numeric_only=True)
# Parameter numeric_only=True memastikan hanya kolom numerik yang dihitung korelasinya

# Visualisasi Correlation Matrix menggunakan Heatmap
plt.figure(figsize=(12, 10))  # Atur ukuran plot agar lebih mudah dibaca
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=.5)

plt.title('Correlation Matrix Antar Fitur')
plt.show()

"""Berdasarkan visualisasi tersebut, variabel yang sebaiknya ditangani outliernya untuk predictive analysis Price adalah `Price`, `Max speed knots`, `Rcmnd cruise Knots`, `Length ft/in`, dan `All eng rate of climb`"""

outlier_cols = ['Price', 'Max speed Knots', 'Rcmnd cruise Knots', 'Length ft/in', 'All eng rate of climb']
# Menentukan quartile dan IQR
Q1 = df[outlier_cols].quantile(0.25)
Q3 = df[outlier_cols].quantile(0.75)
IQR = Q3 - Q1

# Batas bawah dan atas
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Mengatasi outlier dengan metode capping
for col in outlier_cols:
    df[col] = np.where(df[col] < lower_bound[col], lower_bound[col], df[col])
    df[col] = np.where(df[col] > upper_bound[col], upper_bound[col], df[col])

# Cek, bandingkan outlier
# Menentukan quartile dan interquartile
q1 = df[numeric_cols].quantile(0.25)
q3 = df[numeric_cols].quantile(0.75)
IQR = q3 - q1
# Menentukan batas bawah dan atas untuk mendeteksi outlier
lower_bound = q1 - 1.5 * IQR
upper_bound = q3 + 1.5 * IQR

# Menampilkan jumlah outlier per fitur
outliers = ((df[numeric_cols] < lower_bound) | (df[numeric_cols] > upper_bound)).sum()
print(outliers)

"""#### Encoding Fitur Kategorik"""

distinct_engine = df["Engine Type"].unique()
print(distinct_engine)

# One Hot Encoding untuk fitur 'Engine type'
engine_dummies = pd.get_dummies(df['Engine Type'], prefix='Engine', drop_first=True)

# Menggabungkan hasil encoding dengan dataset
df = pd.concat([df, engine_dummies], axis=1)

# Drop kolom asli jika tidak diperlukan lagi
df.drop('Engine Type', axis=1, inplace=True)

# Verifikasi hasil
print(df.head())

"""#### Feature selection (karena terdapat fitur yang multikolinear)"""

# Memisahkan fitur dan target
X = df.drop(columns=['Price'])
y = df['Price']

# Feature selection
selector = SelectKBest(score_func=f_regression, k=10)
X_selected = selector.fit_transform(X, y)
selected_features = X.columns[selector.get_support()]
X = X[selected_features]  # simpan fitur terbaik saja

"""#### Splitting Data"""

# Numeric_cols tanpa price
numeric_cols = X.select_dtypes(include=['int64', 'float64']).columns.tolist()
# Split data
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
) # Data test 20%

"""#### Standarisasi hanya fitur numerik"""

# Hitung mean dan standar deviasi
print("Mean per kolom:")
print(df[numeric_cols].mean())

print("\nStandar Deviasi per kolom:")
print(df[numeric_cols].std())

# Hitung nilai minimum dan maksimum
print("\nMinimum per kolom:")
print(df[numeric_cols].min())

print("\nMaksimum per kolom:")
print(df[numeric_cols].max())

# Inisialisasi RobustScaler
scaler = RobustScaler()

# Fit dan transformasi data hanya pada kolom numerik
X_train[numeric_cols] = scaler.fit_transform(X_train[numeric_cols])
X_test[numeric_cols] = scaler.transform(X_test[numeric_cols])  # Menggunakan transform saja, supaya tidak ada leak dari data uji

X_train.head()

"""### Pemodelan regresi

Pemodelan regresi yang dilakukan ke dataset yang sudah di-preprocess tujuannya adalah untuk memprediksi nilai keluaran yang kontinu atau numerik berdasarkan satu atau lebih variabel input (fitur).
"""

# Inisialisasi model
lr_model = LinearRegression()

# Latih model
lr_model.fit(X_train, y_train)

# Prediksi
y_pred_lr = lr_model.predict(X_test)

# Definisi parameter grid yang ingin dicoba
param_grid = {
    'n_estimators': [100, 200, 300],
    'max_depth': [None, 10, 20],
    'min_samples_split': [2, 5],
    'min_samples_leaf': [1, 2]
}

# Inisialisasi model
rfr = RandomForestRegressor(random_state=42)

# Grid Search (Hyperparameter Tuning)
grid_search = GridSearchCV(estimator=rfr, param_grid=param_grid,
                           cv=5, scoring='neg_mean_squared_error', n_jobs=-1)

# Latih model
grid_search.fit(X_train, y_train)

# Model terbaik dari Grid Search
best_rfr_model = grid_search.best_estimator_

# Prediksi
y_pred_rfr = best_rfr_model.predict(X_test)

"""### Evaluasi Model

Evaluasi model yang dilakukan bertujuan untuk mengukur seberapa baik kinerja model Anda dalam membuat prediksi atau keputusan yang akurat dan relevan pada data baru yang belum pernah dilihat sebelumnya.
"""

# Evaluasi Linear Regression
mae_lr = mean_absolute_error(y_test, y_pred_lr)
rmse_lr = np.sqrt(mean_squared_error(y_test, y_pred_lr))
r2_lr = r2_score(y_test, y_pred_lr)

print("=== Evaluasi Model: Linear Regression ===")
print(f"MAE  : {mae_lr:.2f}")
print(f"RMSE : {rmse_lr:.2f}")
print(f"R2   : {r2_lr:.4f}")

# Evaluasi
mae_rfr = mean_absolute_error(y_test, y_pred_rfr)
rmse_rfr = np.sqrt(mean_squared_error(y_test, y_pred_rfr))
r2_rfr = r2_score(y_test, y_pred_rfr)
mse_rfr = mean_squared_error(y_test, y_pred_rfr)

print("=== Evaluasi Model: Random Forest Regressor ===")
print("Best Parameters:", grid_search.best_params_)
print(f"MAE  : {mae_rfr:.2f}")
print(f"RMSE : {rmse_rfr:.2f}")
print(f"MSE  : {mse_rfr:.2f}")
print(f"R2   : {r2_rfr:.4f}")

"""### Kesimpulan

Berdasarkan hasil evaluasi dua model regresi yang digunakan, yaitu Linear Regression dan Random Forest Regressor, diperoleh bahwa model Random Forest memiliki performa prediktif yang lebih baik dibandingkan Linear Regression. Linear Regression menghasilkan nilai R² sebesar 0,820, MAE sebesar 314.165,48, dan RMSE sebesar 427.787,68. Meskipun cukup baik, model ini cenderung kurang mampu menangkap hubungan non-linear dalam data.

Sementara itu, hasil optimisasi hyperparameter menggunakan GridSearchCV pada model Random Forest Regressor menghasilkan kombinasi parameter terbaik yaitu: n_estimators=300, max_depth=None, min_samples_split=2, dan min_samples_leaf=1. Dengan konfigurasi ini, model menghasilkan R² sebesar 0,878, MAE sebesar 243.975,85, dan RMSE sebesar 352.628,35. Ini menunjukkan bahwa model dapat menjelaskan sekitar 87,8% variasi pada data target, dengan rata-rata kesalahan prediksi sekitar 352 ribu dollar terhadap harga pesawat yang berada dalam skala jutaan dollar. Nilai MSE yang besar (124.346.754.347,05) dapat dimaklumi mengingat skala harga yang besar pula.

Secara keseluruhan, Random Forest Regressor terbukti lebih unggul dibandingkan Linear Regression dalam memprediksi harga pesawat pada dataset ini. Hal ini dikarenakan kemampuannya dalam menangani hubungan kompleks antar fitur, serta fleksibilitas dalam membentuk struktur pohon keputusan yang optimal.
"""